# 【JVM系列】内存布局详解
- URL: https://juejin.cn/post/7424176544668860456
- Added At: 2024-10-12 07:11:13
- [Link To Text](2024-10-12-【jvm系列】内存布局详解_raw.md)

## TL;DR
本文介绍了 JVM 内存管理的特点，包括自动内存回收与手动管理的区别，详细解析了 JVM 的内存结构（如程序计数器、虚拟机栈、堆等），并探讨了相关异常处理。强调了理解 JVM 内存结构对问题定位的重要性，并预告了后续的内存调优内容。

## Summary
1. **内存管理差异**：
   - Java 无需手动回收内存，对象可由 JVM 自动回收。
   - C、C++ 等语言需要开发者手动释放内存。

2. **内存溢出异常**：
   - `OutOfMemoryError` 异常表示内存不足。
   - 异常信息显示虚拟机堆内存空间不足。

3. **JVM 内存结构重要性**：
   - 了解 JVM 内存结构有助于快速定位和解决问题。

4. **JVM 内存结构概述**：
   - 程序计数器、虚拟机栈、本地方法栈、堆、方法区等数据区域。
   - 程序计数器、虚拟机栈、本地方法栈为线程私有。
   - 堆和方法区为线程共享。

5. **程序计数器**：
   - 存储当前线程执行的字节码行号指示器。
   - 线程私有的内存区域，生命周期与线程相同。
   - 唯一一个在 JVM 规范中没有规定 `OutOfMemoryError` 情况的区域。

6. **虚拟机栈**：
   - 线程私有的内存区域，生命周期与线程相同。
   - 描述 Java 方法执行时的内存模型，每个方法对应一个栈帧。
   - 栈帧包含局部变量表、操作数栈、动态链接、方法出口等。

7. **虚拟机栈内部结构**：
   - 局部变量表：存储方法参数和局部变量。
   - 操作数栈：后入先出的栈，用于执行指令运算。
   - 动态链接：与运行时常量池的方法引用建立链接。
   - 方法出口：保存方法返回地址，用于方法返回。

8. **虚拟机栈异常**：
   - `StackOverFlowError`：请求的栈深度大于虚拟机栈所允许的深度。
   - `OutOfMemoryError`：虚拟机栈动态扩展时无法申请足够内存。

9. **本地方法栈**：
   - 为虚拟机使用到的 `Native` 方法服务。
   - 与虚拟机栈类似，可能抛出 `StackOverflowError` 和 `OutOfMemoryError` 异常。

10. **堆**：
    - 所有线程共享的最大内存区域，用于存放对象实例。
    - 划分为年轻代（Eden 区、From Survivor 区、To Survivor 区）和老年代。
    - 新创建的对象首先放在 Eden 区，经历回收后可能转移到老年代。

11. **方法区**：
    - 多个线程共享区域，用于存储类的信息、静态变量、常量等。
    - 也称为 Non-Heap（非堆），GC 收集较少。

12. **运行时常量池**：
    - 方法区的一部分，用于存放编译期生成的字面量和符号引用。
    - 具备动态性，运行期间可能将新的常量放入池中。

13. **直接内存**：
    - 不是虚拟机运行时数据区的一部分，但可能抛出 `OutOfMemoryError` 异常。
    - JDK1.4 中引入 NIO 机制，允许 Java 程序直接从操作系统中分配内存。

14. **总结**：
    - 通过分析，对 JVM 内存结构及相关区域用途有了初步了解。

15. **后续内容**：
    - 将介绍 JVM 内存相关的调优参数。

16. **参考**：
    - 列出了多个参考链接，包括知乎专栏、博客文章等。

17. **JVM 系列文章索引**：
    - 提供了 JVM 系列文章合集的索引链接，方便读者查看相关内容。
