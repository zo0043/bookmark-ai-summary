# AQS 很多人都没有讲明白 
- URL: https://juejin.cn/post/7428927105612185627
- Added At: 2024-10-28 09:58:28
- [Link To Text](2024-10-28-aqs-很多人都没有讲明白_raw.md)

## TL;DR
本文深入剖析AbstractQueuedSynchronizer（AQS）原理，通过图文和调试展示多线程环境下锁的抢占与释放过程，强调AQS设计优点，并指出未涉及细节及局限性。旨在弥补现有文章不足，帮助读者清晰理解AQS机制。

## Summary
1. **AQS文章现状**：作者对现有关于AbstractQueuedSynchronizer（AQS）的文章质量表示失望，认为大多数文章在关键部分含糊其词或直接跳过，仅进行源码的粘贴和注释，缺乏深入的解释和清晰的原理阐述。

2. **本文目的**：作者决定撰写一篇新的文章，旨在清晰地解释AQS的基础原理，并通过图文和断点调试的方式，尽可能详细地展现AQS在多线程环境下的运行状态。

3. **环境说明**：
   - 使用IntelliJ IDEA 2024.2进行代码编写和调试。
   - 使用JDK1.8作为开发环境。

4. **线程知识储备**：
   - **LockSupport**：介绍了LockSupport接口的`park()`和`unpark(Thread thread)`方法，用于线程的挂起和唤醒。
   - **ReentrantLock**：说明了ReentrantLock依赖于Sync类，而Sync继承自AQS。同时介绍了公平锁（FairSync）和非公平锁（NonFairSync）的概念。
   - **CAS**：解释了Compare-And-Swap操作的原理，它是实现无锁线程安全操作的重要手段。
   - **线程模式**：列出了SHARED和EXCLUSIVE两种线程模式，分别代表线程以共享和独占的方式等待锁。

5. **代码准备**：作者准备了一段用于演示的代码，三个线程（A、B、C）争夺锁资源，并通过ReentrantLock的非公平锁实现。

6. **多线程调试技巧**：
   - **查看运行栈帧和切换线程**：在Threads & Variables窗口中切换线程，以便观察不同线程的执行状态。
   - **断点暂停方式**：选择Thread作为断点暂停方式，以便进行断点追踪。

7. **抢占锁过程演示**：
   - **线程A获取锁**：通过CAS操作尝试设置state状态，如果成功则获得锁，否则进入acquire流程。
   - **线程B抢占锁**：由于线程A已经持有锁，线程B尝试获取锁失败后，会进入队列等待。
   - **线程C抢占锁**：线程C的逻辑与线程B相似，也会进入队列等待。

8. **锁释放过程**：
   - **释放逻辑**：当锁持有线程执行完毕后，会调用`unlock()`方法释放锁，这将导致state状态更新，并唤醒等待队列中的线程。
   - **唤醒等待线程**：通过`unparkSuccessor()`方法唤醒队列中的下一个线程。

9. **总结**：
   - **锁抢占和释放过程**：总结了线程从抢占锁到释放锁的整个过程，包括队列的创建和线程的挂起与唤醒。
   - **AQS代码设计优点**：赞扬了AQS的模板方法设计模式、CAS操作的使用、对锁获取的优化尝试以及清晰的变量值设计。
   - **未涉及知识和弊端**：作者承认文章未涉及中断获取、条件判断、异常情况等细节，并指出以ReentrantLock为例进行讲解存在一定的局限性。
   - **head节点设计**：作者提出了自己对head节点不携带线程信息的看法，认为这种设计可以减少队列的创建和销毁，从而提升性能。

10. **结语**：作者表达了对AQS深入理解的满足感，并结束了文章。
