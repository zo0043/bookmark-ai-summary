# 基于实时 CPU 使用率的 Kubernetes 自定义调度器揭开Kubernetes调度的神秘面纱
- URL: https://juejin.cn/post/7427399875236528191
- Added At: 2024-10-26 09:12:13
- [Link To Text](2024-10-26-基于实时-cpu-使用率的-kubernetes-自定义调度器揭开kubernetes调度的神秘面纱_raw.md)

## TL;DR
本文介绍了作者开发自定义Kubernetes控制器的经验，旨在优化Flink任务调度，提升资源利用率。详细讲解了Kubernetes调度器原理、自定义控制器开发流程及实际应用场景，强调了扩展性、性能优化和安全性考虑，为复杂调度需求提供解决方案。

## Summary
1. **作者介绍**：作者LEE，IT行业17年的技术老兵，坚持分享有价值的内容，希望通过简单易懂的方式让更多人掌握实战技能。

2. **文章目的**：分享如何开发自定义Kubernetes控制器，帮助读者理解其工作原理、开发场景和快速上手方法。

3. **案例背景**：作者公司迁移Flink任务至Kubernetes集群，遇到节点过热导致的性能问题，需要优化TaskManager Pod的调度策略。

4. **案例特点**：
   - TaskManager Pod资源使用波动大。
   - 每次任务提交生成新Pod，资源利用率不均。
   - Pod之间存在依赖关系。

5. **案例展示**：开发自定义调度器解决Flink任务调度问题，通过评分算法和运行效果展示优化成果。

6. **自定义调度器的应用场景**：
   - 任务调度优化：针对特定应用、资源敏感型应用、数据局部性等。
   - 资源利用率提升：多维度资源调度、动态负载均衡、资源预留与超售等。
   - 高可用性保障：跨故障域分布、亲和性与反亲和性、灾难恢复优化等。
   - 业务场景定制：合规性要求、性能优化、成本优化等。
   - 多租户资源隔离：资源配额管理、优先级调度、安全隔离等。

7. **Kubernetes调度器101**：
   - 调度器的作用：负责将Pod调度到合适的节点上运行。
   - 调度器的工作流程：Pod列表获取、节点列表获取、过滤节点、优选节点、绑定Pod。
   - 调度策略：资源请求和限制、节点亲和性和反亲和性、Pod亲和性和反亲和性、污点和容忍度。
   - 调度器内部机制：过滤器（Predicates）、优选器（Priorities）、调度算法。
   - 调度器的扩展性：调度器插件（Plugins）、调度器策略、调度器扩展（Scheduler Extenders）。
   - 实际应用场景举例：资源检查、过滤节点、优选节点、绑定Pod。

8. **开发自己的Kubernetes控制器**：
   - 案例背景与目标：创建基于Prometheus实时CPU使用率数据的自定义调度器。
   - 开发环境配置与依赖安装：使用Go语言和Kubernetes客户端库。
   - 自定义调度器的设计与实现：
     - 实时CPU使用率数据获取：使用Prometheus客户端库查询数据。
     - 自定义调度器的实现：实现Filter和Score逻辑，根据CPU使用率为节点打分。
   - 构建 Docker 镜像：创建Dockerfile并构建镜像。
   - 部署自定义调度器：创建RBAC、ConfigMap和Deployment文件，部署到Kubernetes集群。
   - 验证自定义调度器：创建测试Pod并验证调度情况。

9. **课后思考**：
   - 扩展性与适应性：考虑更多调度因素，设计动态调整策略的调度器。
   - 性能与可扩展性：优化查询、设计分布式调度器。
   - 容错与高可用：备选方案、异常处理机制、多副本部署和热备份策略。
   - 安全性考虑：权限管理、数据保护、抗攻击能力。
   - 监控与调优：关键性能指标监控、日志记录、持续优化策略。

10. **总结**：
    - 主要收获：理解Kubernetes调度器、解决实际问题、自定义控制器开发流程、性能优化与扩展性设计、监控与持续优化。
    - 展望与未来：复杂调度策略、跨集群与多云调度、机器学习驱动决策、安全与合规性。
