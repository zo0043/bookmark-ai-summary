# Don’t Implement Unification by Recursion
- URL: https://www.philipzucker.com/unify/
- Added At: 2024-10-29 03:55:45
- [Link To Text](2024-10-29-don’t-implement-unification-by-recursion_raw.md)

## TL;DR
统一是解决方程的形式方法，常见于一阶句法统一。实现上，循环命令式比递归函数式更简洁。统一类似双边模式匹配，可用于推理系统。递归和循环形式各有优劣，选择取决于应用场景。统一强大但复杂，适用于提问和推断新事实。

## Summary
1. **统一简介**：统一是形式方法中用于解决方程的术语。

2. **常见形式**：最常见的统一形式是一阶句法统一。当它成功时，它解决一堆方程，无论实际函数代表什么。

3. **实现挑战**：实际上实现统一，类似于大多数其他操作变量的算法，是我的存在中的祸害。我尽量避免它。

4. **实现方式**：令人惊讶的是，统一在循环命令式突变风格中比在递归函数纯风格中更干净、更容易实现。在我个人的看法中，定理证明/数学算法在第二种风格中通常更干净。统一有太多的远距离诡异行为，一个线程状态，并且可以使用访问堆栈的todo队列来规范它或重新排序它。

5. **递归形式**：如果你需要在完成你所做的事情后重建一个术语，递归形式可能很方便。在手动todo列表形式中，你需要存储某种形式的拉链来复制它。统一通常只返回一个替换，而不是原始输入术语专门替换（尽管这对于关键对、缩小等很有用）。因此，对于统一来说，递归的这个好处并不是很有用。

6. **模式匹配**：统一可以看作是双边的模式匹配。模式匹配（如python的新match-case结构）接受一些树，并允许你将其与模式匹配。模式可能包含变量，当模式匹配时，该分支的`case`具有绑定变量。统一允许你将模式与模式匹配。在一个可能的低级实现中，变量是refcells。统一通过指针操作工作，将refcell指向树的一部分或另一个refcell。对于像rust这样的低级语言，支持基于指针的统一作为类似于match语句的东西会很酷。在逻辑编程语言中，我们通常同时有统一和回溯。这些功能并不是内在耦合的。

7. **推理规则**：统一可以作为推理系统来表示。

8. **推理规则与代码**：与伪代码相比，推理规则有时很好。它们使事物感觉更数学。它们可以清楚地说明如何进行选择。如果你知道prolog，规则很酷，因为你可以将它们写成prolog子句。

9. **推理规则的缺点**：推理规则是入门的障碍，从规则到任何可实现的算法的飞跃可能非常不平凡。

10. **推理规则示例**：`delete`删除一个琐碎的方程，`decompose`匹配头，然后将它们的子项组合在一起，`orient`将变量放在lhs上，`eliminate`取一个解决的方程，并将其替换到所有地方。

11. **todo队列**：todo队列基本上是我们的多重集`S`，我们选择一个特定的顺序来处理方程。

12. **递归与迭代的比较**：像许多算法一样，有递归和迭代版本。迭代版本或多或少地将递归版本的调用堆栈具体化为一个普通的数据结构，保留一个要处理的todo队列。

13. **递归与迭代的实现**：你可以选择是纯粹函数式地还是突变式地操作你正在构建的替换。

14. **递归形式**：最后是递归形式。所有查找和懒惰使我感到困惑。这基本上是将懒惰迭代形式转换回递归。

15. **递归形式的限制**：我们基本上已经移除了检查我们的todo中要处理的下一个方程的能力。我们被迫选择一些顺序，然后也许通过一些奇怪的延续东西或返回冻结的约束来检索该顺序。

16. **其他实现**：还有一些其他的统一实现可以比较。

17. **递归与循环的选择**：我更喜欢循环形式，因为它更容易访问todo队列。

18. **推理规则的实现**：我们可以选择将一个函数用于每个推理规则，或者将推理规则递归地调用其他推理规则。

19. **逻辑形式**：存在和全称量词的正确范围也是一个相关的问题。

20. **E-unification和Egraph**：一个有趣的统一风格是维护两个映射。

21. **其他统一算法**：还有一些其他的统一算法可以比较。

22. **Z3统一**：统一对于提问（存在）和推断新事实很有用。

23. **结论**：统一是一个强大的工具，但实现起来可能很复杂。递归和循环形式各有利弊，选择哪种形式取决于具体的应用场景和个人偏好。
