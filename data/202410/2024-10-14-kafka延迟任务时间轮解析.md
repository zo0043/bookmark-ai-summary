# Kafka延迟任务时间轮解析
- URL: https://juejin.cn/post/7392848248488263695
- Added At: 2024-10-14 15:57:51
- [Link To Text](2024-10-14-kafka延迟任务时间轮解析_raw.md)

## TL;DR
本文介绍了Kafka时间轮算法，包括单层时间轮的原理、任务添加与执行规则，以及时间轮的升级和降级机制。通过DelayQueue解决CPU空转问题，并提供了Java版源码链接。该算法有效支持任意时长延时任务，优化资源利用。

## Summary
1. **单层时间轮原理**
   - **基本概念**：
     - 想象一个时钟，指针每1秒移动一次，转完一圈需要20秒。
   - **任务添加与执行**：
     - **任务添加**：假设0时刻提交一个任务，希望3秒后执行，任务会被放到索引为3的位置。
     - **任务执行**：当当前时间来到3秒，该任务开始执行。
   - **时间范围动态调整**：
     - 当时间来到3秒，支持的时间范围变为3-22秒，任务会根据新的时间范围重新计算位置。
   - **任务添加规则**：
     - 如果任务时间超过当前时间轮支持范围，任务不能添加（触发时间轮升级）。
     - 如果任务时间小于当前时间+1秒，任务应立即执行。
     - 合法任务会被添加到相应索引位置。

2. **时间轮升级和降级**
   - **升级机制**：
     - 当添加的任务超过当前时间轮支持范围，创建新的时间轮，新时间轮的单个节点时间跨度是当前时间轮的总支持时间。
   - **降级机制**：
     - 当内层时间轮走完一圈，外层时间轮推动一个节点，触发时间轮降级。
     - 外层时间轮的节点降级到下一层时间轮，任务根据新的时间范围重新计算位置。
   - **总结**：
     - 通过升级和降级，支持任意时长的延时任务。
     - 添加元素优先从内层时间轮开始，不能添加则添加到外层时间轮。

3. **CPU空转问题解决**
   - **问题描述**：
     - 长时间任务导致内层时间轮多次空转，浪费CPU资源。
   - **解决方案**：
     - 将所有任务添加到Java的DelayQueue中，按执行时间排序。
     - DelayQueue中存储相同时间刻度的任务列表，减少元素个数和插入复杂度。
     - 到点取出任务后进行时间轮降级，任务触发逻辑在降级过程中处理。
   - **任务消费线程伪代码**：
     ```java
     while (true) {
        Task task = delayQueue.take();
        timingWheel.add(task);
     }
     ```

4. **源码提供**
   - Kafka时间轮算法的Java版本源码链接：
     - [TimingWheel-Kafka (gitee.com)](https://gitee.com/K0n9DiKuA/TimingWheel-Kafka)

通过以上结构和详细描述，全面总结了Kafka延迟任务时间轮的原理、实现机制及Java版源码。
