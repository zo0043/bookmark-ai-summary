# 多线程读写锁产生死锁的故障解决方案
- URL: https://mp.weixin.qq.com/s/m6JPAkwUdNivsOGft-lR8w
- Added At: 2025-01-07 12:47:32
- [Link To Text](2025-01-07-多线程读写锁产生死锁的故障解决方案_raw.md)

## TL;DR
文章分析了线上trpc-go服务OOM故障，发现由读写锁读锁重入导致死锁，提出解决方案并探讨不同语言的读写锁实现与优先级策略。

## Summary
1. **故障背景**：
   - 线上trpc-go服务出现OOM，疑似由协程泄露导致。
   - 请求量未上涨，但协程数持续上涨，排除请求积压原因。

2. **排查思路**：
   - **检查请求量级**：确认请求量未上涨，排除请求积压原因。
   - **检查协程泄露**：使用pprof工具发现协程积压在gopark函数等待，定位到读写锁的加锁行为。
   - **定位协程泄漏点**：分析代码，发现读写锁的读锁和写锁加锁顺序导致协程泄露。

3. **读写锁原理**：
   - **适用场景**：适用于多读者-多写者问题，提升读性能。
   - **优先级策略**：读优先、写优先、不指定优先级。
   - **源码分析**：golang RWMutex实现采用writer-preferring策略，通过信号量等待和唤醒实现读-写互斥。

4. **问题总结**：
   - **故障原因**：读锁的重入导致死锁。
   - **解决方案**：避免重复调用锁，保持临界区小，避免嵌套调用函数，小心使用defer释放锁。
   - **拓展思考**：
     - **golang**：RWMutex不可复制，重入读锁导致死锁，释放未加锁的RWMutex或重复释放。
     - **pthread-c**：读写锁实现采用writer-preferring策略，未指定读写锁优先级。
     - **C++**：C++17提供的shared_mutex实现读写锁，标准未定义读写锁优先级。
